<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LemonNES</title>
  <link rel="icon" type="image/jpeg" href="favicon.jpg">
  <style>
    :root { --bg:#0b0f14; --fg:#e8f0ff; --muted:#8aa0b6; --acc:#73d7ff; --card:#121926; }
    html,body{
      height:100%; margin:0; background:var(--bg); color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      /* --- Prevent scroll --- */
      overflow-x: hidden;
      overflow-y: hidden;
      touch-action: none;
    }
    body {
      min-height: 100vh;
      min-width: 100vw;
    }
    .wrap{display:grid; grid-template-columns: 1fr 340px; gap:16px; padding:16px; box-sizing:border-box;}
    header{grid-column: 1 / -1; display:flex; align-items:center; justify-content:space-between}
    header h1{font-size:18px; margin:0; font-weight:600}
    header .sub{color:var(--muted); font-size:12px}
    .screen{background:#000; padding:8px; border-radius:16px; box-shadow: 0 10px 30px rgba(0,0,0,.35);
      display:flex; align-items:center; justify-content:center;}
    canvas{image-rendering: pixelated; image-rendering: crisp-edges; border-radius:12px; background:#000; touch-action:none;}
    .side{background:var(--card); border:1px solid rgba(255,255,255,.06); border-radius:16px; padding:12px;}
    .row{display:flex; align-items:center; gap:10px;}
    .row + .row{margin-top:10px}
    label{font-size:12px; color:var(--muted)}
    .stat{font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono"; color:#99b3cc}
    button, input[type="file"]::file-selector-button{background:#1a2433; color:var(--fg); border:1px solid rgba(255,255,255,.08); padding:8px 10px; border-radius:12px; cursor:pointer}
    button:disabled{opacity:.5; cursor:not-allowed}
    .kbd{display:inline-block; padding:.1rem .4rem; border-radius:6px; background:#0e1624; border:1px solid rgba(255,255,255,.05); font:11px ui-monospace}
    details{margin-top:10px}
    summary{cursor:pointer; color:var(--acc)}
    ul{margin:.25rem 0 .5rem 1.25rem}
    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:6px}
    /* Mobile controls overlay */
    .mobile-controls {
      display: none;
      position: fixed;
      left: 0; right: 0; bottom: 0;
      z-index: 1000;
      pointer-events:none;
    }
    .mobile-controls.active {
      display: flex;
      pointer-events: auto;
      flex-direction: row;
      justify-content: space-between;
      width: 100vw;
      padding: 0 2vw 2vw 2vw;
      box-sizing: border-box;
      user-select: none;
    }
    .dpad, .abpad {
      display: grid;
      grid-template-columns: repeat(3, 44px);
      grid-template-rows: repeat(3, 44px);
      gap: 4px;
    }
    .abpad {
      grid-template-columns: 44px 44px;
      grid-template-rows: 44px 44px;
      gap: 16px;
      align-self: flex-end;
    }
/* NES‑style button overrides */
.mobile-btn {
  background: #1a2433 !important;
  border: 2px solid #567 !important;
  border-radius: 8px !important;
  color: #e0e8ff !important;
  font-size: 18px !important;
  font-family: ui-monospace !important;
  width: 44px !important;
  height: 44px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  user-select: none !important;
  touch-action: none !important;
  transition: background 0.1s !important;
  pointer-events: auto !important;
}

/* Red A/B buttons */
.mobile-btn.red {
  background: #c00 !important;
  border-color: #900 !important;
  color: #fff !important;
}

/* Start / Select smaller buttons */
.mobile-btn.small {
  width: 60px !important;
  height: 28px !important;
  font-size: 12px !important;
  border-radius: 6px !important;
}

/* Pressed state */
.mobile-btn:active,
.mobile-btn.pressed {
  background: #73d7ff !important;
  color: #000 !important;
}{
      background:rgba(80,180,255,0.55);
      color:#000;
    }
    @media (max-width: 900px) {
      html,body {
        overflow-x: hidden;
        overflow-y: hidden;
        touch-action: none;
      }
      .wrap { display: block; padding: 2vw; }
      .side { margin-top: 20px; }
      .screen { justify-content: center; }
      canvas { width: 98vw !important; height: auto !important; max-width: 100vw; max-height: 70vw; }
      .mobile-controls { display: flex !important; }
    }
    @media (pointer: coarse) {
      .mobile-controls { display: flex !important; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>LemonNES <span class="sub">- Should Load Most ROMs And Homebrew</span></h1>
        <div class="sub">Expect Minor Graphical Bugs</div>
      </div>
      <div class="stat" id="build"></div>
    </header>

    <div class="screen">
      <canvas id="screen" width="256" height="240" style="width:768px;height:720px"></canvas>
    </div>

    <aside class="side">
      <div class="row">
        <input id="rom" type="file" accept=".nes,application/octet-stream" />
        <button id="btnRun" disabled>Run</button>
        <button id="btnPause" disabled>Pause</button>
        <button id="btnReset" disabled>Reset</button>
      </div>
      <div class="row stat">
        <div>ROM: <span id="romName">—</span></div>
      </div>
      <div class="grid2 stat">
        <div>FPS: <span id="fps">0</span></div>
        <div>CPU: <span id="mhz">—</span></div>
        <div>Mapper: <span id="mapper">—</span></div>
        <div>Mirroring: <span id="mirror">—</span></div>
        <div>IRQs: <span id="irqs">—</span></div>
      </div>

      <details>
        <summary>Controls</summary>
        <ul>
          <li>P1: <span class="kbd">Arrow Keys</span>, <span class="kbd">Z</span>=A, <span class="kbd">X</span>=B, <span class="kbd">Enter</span>=Start, <span class="kbd">Right Shift</span>=Select</li>
          <li>Touch: Mobile controls are visible on touch devices</li>
        </ul>
      </details>
    </aside>
  </div>

  <!-- Mobile controls overlay -->
  <div class="mobile-controls" id="mobileControls" aria-hidden="true">
    <div style="flex:1;">
      <div class="dpad">
        <div></div>
        <button class="mobile-btn" data-key="ArrowUp" aria-label="Up">&#8593;</button>
        <div></div>
        <button class="mobile-btn" data-key="ArrowLeft" aria-label="Left">&#8592;</button>
        <div></div>
        <button class="mobile-btn" data-key="ArrowRight" aria-label="Right">&#8594;</button>
        <div></div>
        <button class="mobile-btn" data-key="ArrowDown" aria-label="Down">&#8595;</button>
        <div></div>
      </div>
    </div>
    <div style="flex:1;display:flex;flex-direction:column;align-items:flex-end;justify-content:flex-end;gap:8px;">
      <div class="abpad">
        <button class="mobile-btn" data-key="KeyZ" aria-label="A">A</button>
        <button class="mobile-btn" data-key="KeyX" aria-label="B">B</button>
        <button class="mobile-btn" data-key="Enter" aria-label="Start">Start</button>
        <button class="mobile-btn" data-key="ShiftRight" aria-label="Select">Sel</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const BUILD = new Date().toISOString().replace('T',' ').slice(0,19);
  document.getElementById('build').textContent = `build ${BUILD}`;

  // ===== Utilities =====
  const clamp=(v,min,max)=>v<min?min:v>max?max:v;
  const u8 = n => n & 0xFF;
  const u16 = n => n & 0xFFFF;
  const toHex=(n,len=2)=>('0'.repeat(len)+n.toString(16).toUpperCase()).slice(-len);

  // ===== Controllers =====
  class Controllers{
    constructor(){
      this.state1=0; this.state2=0; this.latch=0; this.shift1=0; this.shift2=0;
      this.keyMap = { // bit order: A,B,Select,Start,Up,Down,Left,Right
        'KeyZ':0, 'KeyX':1, 'ShiftRight':2, 'Enter':3,
        'ArrowUp':4,'ArrowDown':5,'ArrowLeft':6,'ArrowRight':7,
      };
      this.bindKeys();
      this.mobileActive = false;
      this.initMobile();
    }
    bindKeys(){
      window.addEventListener('keydown',e=>{
        if(e.repeat) return;
        if(this.keyMap[e.code]!==undefined){
          this.state1 |= (1<<this.keyMap[e.code]);
          e.preventDefault();
        }
      });
      window.addEventListener('keyup',e=>{
        if(this.keyMap[e.code]!==undefined){
          this.state1 &= ~(1<<this.keyMap[e.code]);
          e.preventDefault();
        }
      });
    }
    write(v){ this.latch = v & 1; if(this.latch){ this.shift1=this.state1; this.shift2=this.state2; }}
    read1(){ const out = this.shift1 & 1; if(!this.latch) this.shift1 = (this.shift1>>>1)|0x80; return out; }
    read2(){ const out = this.shift2 & 1; if(!this.latch) this.shift2 = (this.shift2>>>1)|0x80; return out; }

    // === Mobile controls ===
    initMobile() {
      const mobileControls = document.getElementById('mobileControls');
      if (!mobileControls) return;

      // Detect mobile/touch
      const enableMobile = () => {
        mobileControls.classList.add('active');
        this.mobileActive = true;
      };
      const disableMobile = () => {
        mobileControls.classList.remove('active');
        this.mobileActive = false;
      };
      // Show controls on touch devices or on small screens
      if ('ontouchstart' in window || navigator.maxTouchPoints || window.innerWidth < 900) {
        enableMobile();
      }
      window.addEventListener('resize', ()=>{
        if(window.innerWidth < 900) enableMobile();
        else if(!('ontouchstart' in window || navigator.maxTouchPoints)) disableMobile();
      });

      // For each mobile button, simulate keydown/up
      const btns = mobileControls.querySelectorAll('.mobile-btn');
      for(const btn of btns) {
        const code = btn.dataset.key;
        const bit = this.keyMap[code];
        if(bit === undefined) continue;

        // Touch
        let isPressed = false;
        const press = e => {
          if(isPressed) return;
          isPressed = true;
          this.state1 |= (1<<bit);
          btn.classList.add('pressed');
          e.preventDefault();
        };
        const release = e => {
          isPressed = false;
          this.state1 &= ~(1<<bit);
          btn.classList.remove('pressed');
          e.preventDefault();
        };
        btn.addEventListener('touchstart', press, {passive:false});
        btn.addEventListener('touchend', release, {passive:false});
        btn.addEventListener('touchcancel', release, {passive:false});
        btn.addEventListener('mousedown', press);
        btn.addEventListener('mouseup', release);
        btn.addEventListener('mouseleave', release);
        // Prevent scrolling and double-tap zoom
        btn.addEventListener('contextmenu', e=>e.preventDefault());
      }

      // Prevent scrolling when interacting with controls
      mobileControls.addEventListener('touchmove', e=>{
        if(e.target.classList.contains('mobile-btn')) e.preventDefault();
      }, {passive:false});
    }
  }
  class APU {
  constructor() {
    // Audio Context Setup
    const AC = window.AudioContext || window.webkitAudioContext;
    this.ac = new AC();
    this.bufferSize = 2048;
    this.node = this.ac.createScriptProcessor(this.bufferSize, 0, 1);
    this.node.onaudioprocess = (e) => this.pullSamples(e.outputBuffer.getChannelData(0));
    this.gain = this.ac.createGain();
    this.gain.gain.value = 0.2;
    this.node.connect(this.gain).connect(this.ac.destination);
    
    // CPU Frequency: 1.789773 MHz (NTSC)
    this.cpuFreq = 1789773;
    this.sampleRate = 44100;
    
    // Frame Counter State
    this.frameMode = 0; // 0 = 4-step, 1 = 5-step
    this.frameIRQDisable = false;
    this.frameCounter = 0;
    this.frameIRQ = false;
    this.frameCycle = 0; // Cycle counter for frame sequencer
    
    // 4-step: cycles 3728.5, 7456.5, 11185.5, 14914.5 (then back to 0 at 14915)
    // 5-step: cycles 3728.5, 7456.5, 11185.5, 18640.5 (then back to 0 at 18641)
    this.frame4StepCycles = [7457, 14913, 22371, 29829]; // Doubled for half-cycles
    this.frame5StepCycles = [7457, 14913, 22371, 37281]; // Doubled for half-cycles
    
    // APU Cycle Accumulator (for internal timing)
    this.apuCycle = 0;
    
    // Pulse Channels
    this.pulse1 = this.createPulse(true);
    this.pulse2 = this.createPulse(false);
    
    // Triangle Channel
    this.triangle = this.createTriangle();
    
    // Noise Channel
    this.noise = this.createNoise();
    
    // DMC Channel
    this.dmc = this.createDMC();
    
    // Sample Buffer for Audio Output
    this.sampleBuffer = [];
    this.sampleAccumulator = 0;
    
    // Length Counter Lookup Table
    this.lengthTable = [
      10,254, 20,  2, 40,  4, 80,  6, 160,  8, 60, 10, 14, 12, 26, 14,
      12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30
    ];
    
    // Noise Period Table (NTSC)
    this.noisePeriodTable = [
      4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068
    ];
    
    // DMC Rate Table (NTSC)
    this.dmcRateTable = [
      428, 380, 340, 320, 286, 254, 226, 214, 190, 160, 142, 128, 106, 84, 72, 54
    ];
    
    // Duty Cycle Sequences
    this.dutyTable = [
      [0, 1, 0, 0, 0, 0, 0, 0], // 12.5%
      [0, 1, 1, 0, 0, 0, 0, 0], // 25%
      [0, 1, 1, 1, 1, 0, 0, 0], // 50%
      [1, 0, 0, 1, 1, 1, 1, 1]  // 25% negated
    ];
    
    // Triangle Waveform (32 steps)
    this.triangleSequence = [
      15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0,
       0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15
    ];
  }
  
  createPulse(isChannel1) {
    return {
      enabled: false,
      
      // Registers
      duty: 0,
      lengthHalt: false,
      constantVolume: false,
      volume: 0,
      
      // Sweep Unit
      sweepEnabled: false,
      sweepPeriod: 0,
      sweepNegate: false,
      sweepShift: 0,
      sweepReload: false,
      sweepDivider: 0,
      
      // Timer
      timerPeriod: 0,
      timerValue: 0,
      
      // Sequencer
      dutyValue: 0,
      sequencePos: 0,
      
      // Length Counter
      lengthCounter: 0,
      
      // Envelope
      envelopeStart: false,
      envelopeDivider: 0,
      envelopeCounter: 0,
      envelopeLoop: false,
      
      // Channel identity (for sweep negation difference)
      isChannel1: isChannel1
    };
  }
  
  createTriangle() {
    return {
      enabled: false,
      
      // Registers
      controlFlag: false,
      linearCounterLoad: 0,
      
      // Timer
      timerPeriod: 0,
      timerValue: 0,
      
      // Sequencer
      sequencePos: 0,
      
      // Length Counter
      lengthCounter: 0,
      
      // Linear Counter
      linearCounter: 0,
      linearReloadFlag: false
    };
  }
  
  createNoise() {
    return {
      enabled: false,
      
      // Registers
      lengthHalt: false,
      constantVolume: false,
      volume: 0,
      mode: false,
      timerPeriod: 0,
      
      // Timer
      timerValue: 0,
      
      // LFSR
      shiftRegister: 1,
      
      // Length Counter
      lengthCounter: 0,
      
      // Envelope
      envelopeStart: false,
      envelopeDivider: 0,
      envelopeCounter: 0,
      envelopeLoop: false
    };
  }
  
  createDMC() {
    return {
      enabled: false,
      
      // Registers
      irqEnabled: false,
      loop: false,
      rateIndex: 0,
      
      // Sample
      sampleAddress: 0xC000,
      sampleLength: 0,
      currentAddress: 0,
      bytesRemaining: 0,
      
      // Output Unit
      outputLevel: 0,
      
      // Shift Register
      sampleBuffer: 0,
      sampleBufferEmpty: true,
      shiftRegister: 0,
      bitsRemaining: 0,
      
      // Timer
      timerPeriod: 0,
      timerValue: 0,
      
      // IRQ
      irqFlag: false,
      
      // Silence flag
      silence: true
    };
  }
  
  read(addr) {
    if (addr === 0x4015) {
      let status = 0;
      if (this.pulse1.lengthCounter > 0) status |= 0x01;
      if (this.pulse2.lengthCounter > 0) status |= 0x02;
      if (this.triangle.lengthCounter > 0) status |= 0x04;
      if (this.noise.lengthCounter > 0) status |= 0x08;
      if (this.dmc.bytesRemaining > 0) status |= 0x10;
      if (this.frameIRQ) status |= 0x40;
      if (this.dmc.irqFlag) status |= 0x80;
      
      // Reading $4015 clears frame IRQ flag
      this.frameIRQ = false;
      
      return status;
    }
    return 0;
  }
  
  write(addr, val) {
    val &= 0xFF;
    
    switch (addr) {
      // Pulse 1
      case 0x4000:
        this.pulse1.duty = (val >> 6) & 0x03;
        this.pulse1.lengthHalt = !!(val & 0x20);
        this.pulse1.envelopeLoop = !!(val & 0x20);
        this.pulse1.constantVolume = !!(val & 0x10);
        this.pulse1.volume = val & 0x0F;
        break;
      case 0x4001:
        this.pulse1.sweepEnabled = !!(val & 0x80);
        this.pulse1.sweepPeriod = (val >> 4) & 0x07;
        this.pulse1.sweepNegate = !!(val & 0x08);
        this.pulse1.sweepShift = val & 0x07;
        this.pulse1.sweepReload = true;
        break;
      case 0x4002:
        this.pulse1.timerPeriod = (this.pulse1.timerPeriod & 0x700) | val;
        break;
      case 0x4003:
        this.pulse1.timerPeriod = (this.pulse1.timerPeriod & 0xFF) | ((val & 0x07) << 8);
        this.pulse1.sequencePos = 0;
        this.pulse1.envelopeStart = true;
        if (this.pulse1.enabled) {
          this.pulse1.lengthCounter = this.lengthTable[(val >> 3) & 0x1F];
        }
        break;
        
      // Pulse 2
      case 0x4004:
        this.pulse2.duty = (val >> 6) & 0x03;
        this.pulse2.lengthHalt = !!(val & 0x20);
        this.pulse2.envelopeLoop = !!(val & 0x20);
        this.pulse2.constantVolume = !!(val & 0x10);
        this.pulse2.volume = val & 0x0F;
        break;
      case 0x4005:
        this.pulse2.sweepEnabled = !!(val & 0x80);
        this.pulse2.sweepPeriod = (val >> 4) & 0x07;
        this.pulse2.sweepNegate = !!(val & 0x08);
        this.pulse2.sweepShift = val & 0x07;
        this.pulse2.sweepReload = true;
        break;
      case 0x4006:
        this.pulse2.timerPeriod = (this.pulse2.timerPeriod & 0x700) | val;
        break;
      case 0x4007:
        this.pulse2.timerPeriod = (this.pulse2.timerPeriod & 0xFF) | ((val & 0x07) << 8);
        this.pulse2.sequencePos = 0;
        this.pulse2.envelopeStart = true;
        if (this.pulse2.enabled) {
          this.pulse2.lengthCounter = this.lengthTable[(val >> 3) & 0x1F];
        }
        break;
        
      // Triangle
      case 0x4008:
        this.triangle.controlFlag = !!(val & 0x80);
        this.triangle.linearCounterLoad = val & 0x7F;
        break;
      case 0x400A:
        this.triangle.timerPeriod = (this.triangle.timerPeriod & 0x700) | val;
        break;
      case 0x400B:
        this.triangle.timerPeriod = (this.triangle.timerPeriod & 0xFF) | ((val & 0x07) << 8);
        this.triangle.linearReloadFlag = true;
        if (this.triangle.enabled) {
          this.triangle.lengthCounter = this.lengthTable[(val >> 3) & 0x1F];
        }
        break;
        
      // Noise
      case 0x400C:
        this.noise.lengthHalt = !!(val & 0x20);
        this.noise.envelopeLoop = !!(val & 0x20);
        this.noise.constantVolume = !!(val & 0x10);
        this.noise.volume = val & 0x0F;
        break;
      case 0x400E:
        this.noise.mode = !!(val & 0x80);
        this.noise.timerPeriod = this.noisePeriodTable[val & 0x0F];
        break;
      case 0x400F:
        this.noise.envelopeStart = true;
        if (this.noise.enabled) {
          this.noise.lengthCounter = this.lengthTable[(val >> 3) & 0x1F];
        }
        break;
        
      // DMC
      case 0x4010:
        this.dmc.irqEnabled = !!(val & 0x80);
        this.dmc.loop = !!(val & 0x40);
        this.dmc.rateIndex = val & 0x0F;
        this.dmc.timerPeriod = this.dmcRateTable[this.dmc.rateIndex];
        if (!this.dmc.irqEnabled) {
          this.dmc.irqFlag = false;
        }
        break;
      case 0x4011:
        this.dmc.outputLevel = val & 0x7F;
        break;
      case 0x4012:
        this.dmc.sampleAddress = 0xC000 | (val << 6);
        break;
      case 0x4013:
        this.dmc.sampleLength = (val << 4) | 1;
        break;
        
      // Status
      case 0x4015:
        this.pulse1.enabled = !!(val & 0x01);
        this.pulse2.enabled = !!(val & 0x02);
        this.triangle.enabled = !!(val & 0x04);
        this.noise.enabled = !!(val & 0x08);
        this.dmc.enabled = !!(val & 0x10);
        
        if (!this.pulse1.enabled) this.pulse1.lengthCounter = 0;
        if (!this.pulse2.enabled) this.pulse2.lengthCounter = 0;
        if (!this.triangle.enabled) this.triangle.lengthCounter = 0;
        if (!this.noise.enabled) this.noise.lengthCounter = 0;
        
        if (!this.dmc.enabled) {
          this.dmc.bytesRemaining = 0;
          this.dmc.irqFlag = false;
        } else if (this.dmc.bytesRemaining === 0) {
          this.dmc.currentAddress = this.dmc.sampleAddress;
          this.dmc.bytesRemaining = this.dmc.sampleLength;
        }
        break;
        
      // Frame Counter
      case 0x4017:
        this.frameMode = (val >> 7) & 0x01;
        this.frameIRQDisable = !!(val & 0x40);
        
        if (this.frameIRQDisable) {
          this.frameIRQ = false;
        }
        
        // Writing to $4017 resets the frame counter
        this.frameCycle = 0;
        this.frameCounter = 0;
        
        // If 5-step mode, clock immediately
        if (this.frameMode === 1) {
          this.clockQuarterFrame();
          this.clockHalfFrame();
        }
        break;
    }
  }
  
  step(cpuCycles) {
    // Process each CPU cycle
    for (let i = 0; i < cpuCycles; i++) {
      this.stepAPU();
    }
  }
  
  stepAPU() {
    // Advance frame counter (runs at CPU rate)
    this.frameCycle++;
    
    const cycles = this.frameMode === 0 ? this.frame4StepCycles : this.frame5StepCycles;
    const stepIndex = this.frameCounter;
    
    if (stepIndex < cycles.length && this.frameCycle === cycles[stepIndex]) {
      // Quarter frame clock
      this.clockQuarterFrame();
      
      // Half frame clock (on specific steps)
      if (stepIndex === 1 || stepIndex === 3) {
        this.clockHalfFrame();
      }
      
      this.frameCounter++;
    }
    
    // Frame IRQ (4-step mode only)
    if (this.frameMode === 0 && !this.frameIRQDisable) {
      if (this.frameCycle === 29829 || this.frameCycle === 29830) {
        this.frameIRQ = true;
      }
    }
    
    // Reset frame counter
    const maxCycle = this.frameMode === 0 ? 29830 : 37282;
    if (this.frameCycle >= maxCycle) {
      this.frameCycle = 0;
      this.frameCounter = 0;
    }
    
    // Clock channels at APU rate (every other CPU cycle)
    if (this.apuCycle % 2 === 0) {
      this.clockPulse(this.pulse1);
      this.clockPulse(this.pulse2);
      this.clockNoise();
    }
    
    // Triangle runs at CPU rate
    this.clockTriangle();
    
    // DMC runs at its own rate
    this.clockDMC();
    
    // Accumulate sample
    this.sampleAccumulator += (this.cpuFreq / this.sampleRate);
    if (this.sampleAccumulator >= 1.0) {
      this.sampleAccumulator -= 1.0;
      const sample = this.mix();
      this.sampleBuffer.push(sample);
    }
    
    this.apuCycle++;
  }
  
  clockQuarterFrame() {
    // Clock envelopes and triangle linear counter
    this.clockEnvelope(this.pulse1);
    this.clockEnvelope(this.pulse2);
    this.clockEnvelope(this.noise);
    this.clockTriangleLinearCounter();
  }
  
  clockHalfFrame() {
    // Clock length counters and sweep units
    this.clockLengthCounter(this.pulse1);
    this.clockLengthCounter(this.pulse2);
    this.clockLengthCounter(this.triangle);
    this.clockLengthCounter(this.noise);
    this.clockSweep(this.pulse1);
    this.clockSweep(this.pulse2);
  }
  
  clockEnvelope(channel) {
    if (channel.envelopeStart) {
      channel.envelopeStart = false;
      channel.envelopeCounter = 15;
      channel.envelopeDivider = channel.volume;
    } else {
      if (channel.envelopeDivider > 0) {
        channel.envelopeDivider--;
      } else {
        channel.envelopeDivider = channel.volume;
        if (channel.envelopeCounter > 0) {
          channel.envelopeCounter--;
        } else if (channel.envelopeLoop) {
          channel.envelopeCounter = 15;
        }
      }
    }
  }
  
  clockLengthCounter(channel) {
    if (!channel.lengthHalt && channel.lengthCounter > 0) {
      channel.lengthCounter--;
    }
  }
  
  clockTriangleLinearCounter() {
    if (this.triangle.linearReloadFlag) {
      this.triangle.linearCounter = this.triangle.linearCounterLoad;
    } else if (this.triangle.linearCounter > 0) {
      this.triangle.linearCounter--;
    }
    
    if (!this.triangle.controlFlag) {
      this.triangle.linearReloadFlag = false;
    }
  }
  
  clockSweep(pulse) {
    const targetPeriod = this.sweepTargetPeriod(pulse);
    const muting = pulse.timerPeriod < 8 || targetPeriod > 0x7FF;
    
    if (pulse.sweepDivider === 0 && pulse.sweepEnabled && !muting && pulse.sweepShift > 0) {
      pulse.timerPeriod = targetPeriod;
    }
    
    if (pulse.sweepDivider === 0 || pulse.sweepReload) {
      pulse.sweepDivider = pulse.sweepPeriod;
      pulse.sweepReload = false;
    } else {
      pulse.sweepDivider--;
    }
  }
  
  sweepTargetPeriod(pulse) {
    const changeAmount = pulse.timerPeriod >> pulse.sweepShift;
    if (pulse.sweepNegate) {
      // Pulse 1 uses one's complement, Pulse 2 uses two's complement
      return pulse.timerPeriod - changeAmount - (pulse.isChannel1 ? 1 : 0);
    } else {
      return pulse.timerPeriod + changeAmount;
    }
  }
  
  clockPulse(pulse) {
    if (pulse.timerValue === 0) {
      pulse.timerValue = pulse.timerPeriod;
      pulse.sequencePos = (pulse.sequencePos + 1) & 0x07;
    } else {
      pulse.timerValue--;
    }
  }
  
  clockTriangle() {
    if (this.triangle.timerValue === 0) {
      this.triangle.timerValue = this.triangle.timerPeriod;
      if (this.triangle.lengthCounter > 0 && this.triangle.linearCounter > 0) {
        this.triangle.sequencePos = (this.triangle.sequencePos + 1) & 0x1F;
      }
    } else {
      this.triangle.timerValue--;
    }
  }
  
  clockNoise() {
    if (this.noise.timerValue === 0) {
      this.noise.timerValue = this.noise.timerPeriod;
      
      const feedback = this.noise.mode 
        ? ((this.noise.shiftRegister >> 6) & 1) ^ (this.noise.shiftRegister & 1)
        : ((this.noise.shiftRegister >> 1) & 1) ^ (this.noise.shiftRegister & 1);
      
      this.noise.shiftRegister = (this.noise.shiftRegister >> 1) | (feedback << 14);
    } else {
      this.noise.timerValue--;
    }
  }
  
  clockDMC() {
    // Timer
    if (this.dmc.timerValue === 0) {
      this.dmc.timerValue = this.dmc.timerPeriod;
      
      if (!this.dmc.silence) {
        if ((this.dmc.shiftRegister & 1) === 1) {
          if (this.dmc.outputLevel <= 125) {
            this.dmc.outputLevel += 2;
          }
        } else {
          if (this.dmc.outputLevel >= 2) {
            this.dmc.outputLevel -= 2;
          }
        }
      }
      
      this.dmc.shiftRegister >>= 1;
      this.dmc.bitsRemaining--;
      
      if (this.dmc.bitsRemaining === 0) {
        this.dmc.bitsRemaining = 8;
        if (this.dmc.sampleBufferEmpty) {
          this.dmc.silence = true;
        } else {
          this.dmc.silence = false;
          this.dmc.shiftRegister = this.dmc.sampleBuffer;
          this.dmc.sampleBufferEmpty = true;
          
          // Trigger sample fetch (simplified - would need CPU memory access)
          if (this.dmc.bytesRemaining > 0) {
            // In real implementation, we'd fetch from CPU memory here
            // For now, just decrement
            this.dmc.bytesRemaining--;
            this.dmc.currentAddress = (this.dmc.currentAddress + 1) | 0x8000;
            
            if (this.dmc.bytesRemaining === 0) {
              if (this.dmc.loop) {
                this.dmc.currentAddress = this.dmc.sampleAddress;
                this.dmc.bytesRemaining = this.dmc.sampleLength;
              } else if (this.dmc.irqEnabled) {
                this.dmc.irqFlag = true;
              }
            }
          }
        }
      }
    } else {
      this.dmc.timerValue--;
    }
  }
  
  getPulseOutput(pulse) {
    if (!pulse.enabled || pulse.lengthCounter === 0) {
      return 0;
    }
    
    // Check sweep muting
    const targetPeriod = this.sweepTargetPeriod(pulse);
    if (pulse.timerPeriod < 8 || targetPeriod > 0x7FF) {
      return 0;
    }
    
    const dutyBit = this.dutyTable[pulse.duty][pulse.sequencePos];
    if (dutyBit === 0) {
      return 0;
    }
    
    const volume = pulse.constantVolume ? pulse.volume : pulse.envelopeCounter;
    return volume;
  }
  
  getTriangleOutput() {
    if (!this.triangle.enabled || this.triangle.lengthCounter === 0 || this.triangle.linearCounter === 0) {
      return 0;
    }
    
    // Ultrasonic silence
    if (this.triangle.timerPeriod < 2) {
      return 0;
    }
    
    return this.triangleSequence[this.triangle.sequencePos];
  }
  
  getNoiseOutput() {
    if (!this.noise.enabled || this.noise.lengthCounter === 0) {
      return 0;
    }
    
    if ((this.noise.shiftRegister & 1) === 1) {
      return 0;
    }
    
    const volume = this.noise.constantVolume ? this.noise.volume : this.noise.envelopeCounter;
    return volume;
  }
  
  getDMCOutput() {
    return this.dmc.outputLevel;
  }
  
  mix() {
    const pulse1 = this.getPulseOutput(this.pulse1);
    const pulse2 = this.getPulseOutput(this.pulse2);
    const triangle = this.getTriangleOutput();
    const noise = this.getNoiseOutput();
    const dmc = this.getDMCOutput();
    
    // NES nonlinear mixing formulas
    let pulseOut = 0;
    if (pulse1 + pulse2 > 0) {
      pulseOut = 95.88 / ((8128.0 / (pulse1 + pulse2)) + 100.0);
    }
    
    let tndOut = 0;
    if (triangle + noise + dmc > 0) {
      tndOut = 159.79 / (1.0 / ((triangle / 8227.0) + (noise / 12241.0) + (dmc / 22638.0)) + 100.0);
    }
    
    return pulseOut + tndOut;
  }
  
  pullSamples(out) {
    const len = out.length;
    for (let i = 0; i < len; i++) {
      if (this.sampleBuffer.length > 0) {
        out[i] = this.sampleBuffer.shift();
      } else {
        // Underrun - repeat last sample
        out[i] = i > 0 ? out[i - 1] : 0;
      }
    }
  }
} 
 // ===== Mappers =====
 class Mapper {
    constructor(cart){ this.cart=cart; }
    prgRead(addr){ return this.cart.prg[addr-0x8000]; }
    prgWrite(addr,val){}
    chrRead(addr){ return this.cart.chr[addr]; }
    chrWrite(addr,val){ if(this.cart.chrRAM) this.cart.chr[addr]=val; }
    ppuA12Rising(){}
    get mirroring(){ return this.cart.mirror; }
  }
  // NROM (0)
  class Mapper0 extends Mapper{
    prgRead(addr){ if(this.cart.prg.length===0x4000 && addr>=0xC000) return this.cart.prg[addr-0xC000]; return this.cart.prg[addr-0x8000]; }
  }
  // MMC1 (1) – minimal (no SRAM/battery, IRQs). Shift register control.
  class Mapper1 extends Mapper{
    constructor(c){ super(c); this.shift=0x10; this.ctrl=0x0C; this.prgBank=0; this.chrBank0=0; this.chrBank1=0; }
    writeReg(addr,val){ if(val&0x80){ this.shift=0x10; this.ctrl|=0x0C; return; }
      const complete = (this.shift & 1); this.shift = (this.shift>>1) | ((val&1)<<4);
      if(complete){ const reg = (addr>>13)&3; const data = this.shift & 0x1F; this.shift=0x10;
        if(reg===0){ this.ctrl=data; this.cart.mirror=['horizontal','vertical','single0','single1'][data&3]||'horizontal'; }
        else if(reg===1){ this.chrBank0=data; }
        else if(reg===2){ this.chrBank1=data; }
        else if(reg===3){ this.prgBank=data & 0x0F; }
      }
    }
    prgRead(addr){ const mode=(this.ctrl>>2)&3; const bank16=(b)=>b*0x4000;
      if(mode===0||mode===1){ // 32K
        const base=(this.prgBank&0x0E)*0x4000; return this.cart.prg[base + (addr-0x8000)];
      } else if(mode===2){ // fix first
        if(addr<0xC000) return this.cart.prg[(addr-0x8000)];
        const base=bank16(this.prgBank); return this.cart.prg[base + (addr-0xC000)];
      } else { // fix last
        const base=bank16(this.prgBank);
        if(addr<0xC000) return this.cart.prg[base + (addr-0x8000)];
        return this.cart.prg[this.cart.prg.length-0x4000 + (addr-0xC000)];
      }
    }
    prgWrite(addr,val){ this.writeReg(addr,val); }
    chrRead(addr){ const mode = (this.ctrl>>4)&1; if(mode===0){ const base=(this.chrBank0&0x1E)*0x1000; return this.cart.chr[base + addr]; } else { const base = (addr<0x1000? this.chrBank0: this.chrBank1)*0x1000; return this.cart.chr[base + (addr&0x0FFF)]; }
    }
    chrWrite(addr,val){ if(this.cart.chrRAM){ const mode=(this.ctrl>>4)&1; if(mode===0){ const base=(this.chrBank0&0x1E)*0x1000; this.cart.chr[base + addr]=val; } else { const base = (addr<0x1000? this.chrBank0: this.chrBank1)*0x1000; this.cart.chr[base + (addr&0x0FFF)]=val; } }
    }
  }
  // UxROM (2)
  class Mapper2 extends Mapper{
    constructor(c){ super(c); this.bank=0; }
    prgRead(addr){ if(addr<0xC000){ const base=this.bank*0x4000; return this.cart.prg[base + (addr-0x8000)]; } return this.cart.prg[this.cart.prg.length-0x4000 + (addr-0xC000)]; }
    prgWrite(addr,val){ this.bank = val & 0x0F; }
  }
  // CNROM (3)
  class Mapper3 extends Mapper{
    constructor(c){ super(c); this.chrBank=0; }
    prgRead(addr){ return this.cart.prg[addr-0x8000]; }
    prgWrite(addr,val){ this.chrBank = val & 0x03; }
    chrRead(addr){ const base=this.chrBank*0x2000; return this.cart.chr[base + addr]; }
  }
  
 // ===== Mapper 4 (MMC3) - FIXED VERSION =====
  class Mapper4 extends Mapper {
    constructor(cart) {
        super(cart);
        this.cpu = null;
        this.ppu = null;

        // Registers
        this.bankSelect = 0;
        this.bankData = new Uint8Array(8);
        this.prgMode = 0;
        this.chrMode = 0;
        
        // IRQ - [FIX] Added reloadPending and proper state tracking
        this.irqLatch = 0;
        this.irqCounter = 0;
        this.irqEnable = false;
        this.irqReloadPending = false;
        
        // Banks
        this.prgBanks = new Uint8Array(4);
        this.chrBanks = new Uint8Array(8);
        
        // Setup default banks
        this.prgBanksTotal = this.cart.prg.length / 0x2000;
        this.lastBank = this.prgBanksTotal - 1;
        this.updatePrgMapping();
        this.updateChrMapping();
    }

    // --- Glue Logic - [REWRITTEN FOR PROPER IRQ TIMING] ---
    ppuCycle() {
        if (!this.ppu) return;
        
        const renderingEnabled = (this.ppu.mask & 0x18) !== 0;
        if (!renderingEnabled) return;
        
        const scanline = this.ppu.scanline;
        const cycle = this.ppu.cycle;
        
        // Clock counter once per scanline at cycle 260 (during HBlank)
        // This is when MMC3 detects the scanline transition
        if (cycle === 260 && scanline >= 0 && scanline <= 239) {
            this.clockCounter();
        }
    }

    // [NEW] Separate method for counter clocking logic
    clockCounter() {
        // [FIX] If reload is pending, reload the counter
        if (this.irqReloadPending) {
            this.irqCounter = this.irqLatch;
            this.irqReloadPending = false;
            return;
        }
        
        // [FIX] Proper counter behavior
        if (this.irqCounter === 0) {
            this.irqCounter = this.irqLatch;
        } else {
            this.irqCounter--;
        }
        
        // [FIX] Trigger IRQ when counter reaches 0 AND IRQ enabled
        if (this.irqCounter === 0 && this.irqEnable && this.cpu) {
            this.cpu.irqLine = true;
        }
    }

    // --- CPU Handling (includes WRAM) ---
    prgRead(addr) {
        // WRAM Access ($6000-$7FFF)
        if (addr >= 0x6000 && addr <= 0x7FFF) {
            return this.cart.sram[addr - 0x6000];
        }
        // Banked ROM Access ($8000-$FFFF)
        let bankIdx = (addr - 0x8000) >> 13;
        let bank = this.prgBanks[bankIdx];
        return this.cart.prg[(bank * 0x2000) + (addr & 0x1FFF)];
    }

    prgWrite(addr, val) {
        // WRAM Write
        if (addr >= 0x6000 && addr <= 0x7FFF) {
            this.cart.sram[addr - 0x6000] = val;
            return;
        }
        // Register Writes
        this.writeRegister(addr, val);
    }

    // --- PPU Handling (includes CHR Mode Swap) ---
    chrRead(addr) {
        let index = addr >> 10;
        let offset = addr & 0x3FF;
        
        // Handle CHR Mode swap
        let bankIndex = this.chrMode === 0 ? index : (index < 4 ? index + 4 : index - 4);
        let bank = this.chrBanks[bankIndex];

        const total = this.cart.chr.length >> 10;
        if (total > 0) bank %= total;

        return this.cart.chr[(bank * 1024) + offset];
    }

    chrWrite(addr, val) {
        if (this.cart.chrROM) return;

        let index = addr >> 10;
        let offset = addr & 0x3FF;
        let bankIndex = this.chrMode === 0 ? index : (index < 4 ? index + 4 : index - 4);
        let bank = this.chrBanks[bankIndex];

        const total = this.cart.chr.length >> 10;
        if (total > 0) bank %= total;

        this.cart.chr[(bank * 1024) + offset] = val;
    }

    // --- Register Implementation ---
    writeRegister(addr, val) {
        if (addr < 0x8000) return;

        if ((addr & 1) === 0) {
            if (addr < 0xA000) {
                this.bankSelect = val;
                const p = (val >> 6) & 1, c = (val >> 7) & 1;
                if (this.prgMode !== p) { this.prgMode = p; this.updatePrgMapping(); }
                if (this.chrMode !== c) { this.chrMode = c; this.updateChrMapping(); }
            } 
            else if (addr < 0xC000) {
                if (this.ppu) this.ppu.mirror = (val & 1) ? 'horizontal' : 'vertical';
            } 
            else if (addr < 0xE000) {
                this.irqLatch = val;
            } 
            else {
                this.irqEnable = false;
                if (this.cpu) this.cpu.irqLine = false;
            }
        } 
        else {
            if (addr < 0xA000) {
                this.bankData[this.bankSelect & 7] = val;
                (this.bankSelect & 7) >= 6 ? this.updatePrgMapping() : this.updateChrMapping();
            }
            else if (addr < 0xC000) { }
            else if (addr < 0xE000) {
                this.irqCounter = 0;
                this.irqReloadPending = true;
            }
            else {
                this.irqEnable = true;
            }
        }
    }

    updatePrgMapping() {
        const b8 = this.prgMode === 0 ? this.bankData[6] : this.lastBank - 1;
        const bC = this.prgMode === 0 ? this.lastBank - 1 : this.bankData[6];
        this.prgBanks[0] = b8;
        this.prgBanks[1] = this.bankData[7];
        this.prgBanks[2] = bC;
        this.prgBanks[3] = this.lastBank;
    }
    
    updateChrMapping() {
        const R = this.bankData;
        this.chrBanks[0] = R[0] & 0xFE; this.chrBanks[1] = R[0] | 1;
        this.chrBanks[2] = R[1] & 0xFE; this.chrBanks[3] = R[1] | 1;
        this.chrBanks[4] = R[2]; this.chrBanks[5] = R[3];
        this.chrBanks[6] = R[4]; this.chrBanks[7] = R[5];
    }
  }
  
 // ===== Mapper 4 (MMC3) =====
  // ===== Cartridge (iNES) =====
  class Cartridge {
    constructor(bytes) {
      // 1. Basic Header Validation
      if (bytes[0] !== 0x4E || bytes[1] !== 0x45 || bytes[2] !== 0x53 || bytes[3] !== 0x1A) {
        throw new Error('Invalid iNES ROM file');
      }

      // 2. Read Header Info
      const prgBanks = bytes[4];
      const chrBanks = bytes[5]; // 0 means CHR-RAM
      const f6 = bytes[6];
      const f7 = bytes[7];

      this.mapper = (f7 & 0xF0) | (f6 >> 4);
      
      // 3. Mirroring
      this.mirror = (f6 & 1) ? 'vertical' : 'horizontal';
      if (f6 & 0x08) this.mirror = 'four';

      // 4. Load PRG ROM
      const hasTrainer = !!(f6 & 0x04);
      let offset = 16 + (hasTrainer ? 512 : 0);
      
      const prgSize = prgBanks * 16384;
      this.prg = bytes.slice(offset, offset + prgSize);
      offset += prgSize;

      // 5. Load CHR ROM or Alloc CHR RAM
      this.chrROM = chrBanks > 0;
      if (this.chrROM) {
        const chrSize = chrBanks * 8192;
        this.chr = bytes.slice(offset, offset + chrSize);
      } else {
        this.chr = new Uint8Array(8192); // 8KB CHR-RAM
      }
      this.chrRAM = !this.chrROM;

      // 6. Alloc Save RAM (WRAM) - Critical for SMB3
      this.sram = new Uint8Array(0x2000); 
    }
  }

  // ===== Bus =====
  class Bus {
    constructor(cpu, ppu, cart, input, apu){ this.cpu=cpu; this.ppu=ppu; this.cart=cart; this.input=input; this.apu=apu; this.ram=new Uint8Array(0x800); }
    cpuRead(addr){ addr&=0xFFFF; if(addr<0x2000){return this.ram[addr&0x7FF];}
      if(addr<0x4000){return this.ppu.read(0x2000 + (addr&7));}
      if(addr===0x4015){return this.apu.read(addr);} // APU status
      if(addr===0x4016){return this.input.read1();}
      if(addr===0x4017){return this.input.read2();}
      if(addr>=0x8000){return this.ppu.mapper.prgRead(addr);} 
      if(addr>=0x6000){return this.ppu.cart.sram[addr-0x6000];}
      return 0; }
    cpuWrite(addr,val){ addr&=0xFFFF; val&=0xFF; if(addr<0x2000){this.ram[addr&0x7FF]=val; return;}
      if(addr<0x4000){this.ppu.write(0x2000 + (addr&7), val); return;}
      if(addr===0x4014){ // OAMDMA
        const page = val<<8; const buf = new Uint8Array(256); for(let i=0;i<256;i++) buf[i]=this.cpuRead(page+i);
        this.ppu.doDMA(buf); this.cpu.stall += 513 + (this.cpu.cycles%2===1?1:0); return;}
      if(addr===0x4016){this.input.write(val); return;}
      if(addr>=0x4000 && addr<=0x4017){ this.apu.write(addr,val); return; }
      if(addr>=0x8000){this.ppu.mapper.prgWrite(addr,val); return;}
      if(addr>=0x6000){this.ppu.cart.sram[addr-0x6000]=val; return;}
    }
  }
  class PPU {
    constructor() {
      this.v = 0;
      this.t = 0;
      this.x = 0;
      this.w = 0;
      this.ctrl = 0;
      this.mask = 0;
      this.status = 0;
      this.oamaddr = 0;
      this.buffered = 0;
      this.openBus = 0;
      this.oam = new Uint8Array(256);
      this.secOAM = new Uint8Array(32);
      this.spriteCount = 0;
      this.spriteZeroInLine = false;
      this.spriteZeroHit = false;
      this.cycle = 0;
      this.scanline = 261;
      this.frame = 0;
      this.nmi = false;
      this.cart = null;
      this.mapper = null;
      this.canvas = null;
      this.ctx = null;
      this.output = null;
      this.vram = new Uint8Array(0x800);
      this.palette = new Uint8Array(32);
      this.bgLatch = { lo: 0, hi: 0, pal: 0 };
      this.oddFrame = false;
      this.nmiDelay = 0;
      
      // Shift registers
      this.bgShiftLo = 0;
      this.bgShiftHi = 0;
      this.bgAttrShiftLo = 0;
      this.bgAttrShiftHi = 0;
      this.bgNextTile = 0;
      this.bgNextAttr = 0;
    }

    attachCanvas(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext("2d", { alpha: false, willReadFrequently: true });
      this.output = this.ctx.createImageData(256, 240);
    }

    connectCart(cart) {
      this.cart = cart;
      this.mapper = [Mapper0, Mapper1, Mapper2, Mapper3, Mapper4][cart.mapper]
        ? new [Mapper0, Mapper1, Mapper2, Mapper3, Mapper4][cart.mapper](cart)
        : new Mapper0(cart);
      if(this.mapper && this.mapper instanceof Mapper4) {
          this.mapper.ppu = this; 
      }
      this.mirror = cart.mirror;
    }

    reset() {
      this.v = this.t = this.x = this.w = 0;
      this.ctrl = this.mask = this.status = this.oamaddr = 0;
      this.cycle = 0;
      this.scanline = 261;
      this.nmi = false;
      this.frame = 0;
      this.oddFrame = false;
      this.nmiDelay = 0;
      this.bgShiftLo = 0;
      this.bgShiftHi = 0;
      this.bgAttrShiftLo = 0;
      this.bgAttrShiftHi = 0;
    }

    read(addr) {
      switch (addr) {
        case 0x2002: {
          const res = (this.status & 0xE0) | (this.buffered & 0x1F);
          this.openBus = res;
          this.status &= ~0x80;
          this.w = 0;
          if (this.nmiDelay > 0) {
            this.nmiDelay = 0;
            this.nmi = false;
          }
          return res;
        }
        case 0x2004:
          return this.oam[this.oamaddr];
        case 0x2007: {
          let value = this.ppuRead(this.v);
          if (this.v < 0x3F00) {
            const temp = this.buffered;
            this.buffered = value;
            value = temp;
          } else {
            this.buffered = this.ppuRead(this.v - 0x1000); 
          }
          this.v += (this.ctrl & 0x04) ? 32 : 1;
          this.v &= 0x7FFF;
          this.openBus = value;
          return value;
        }
        default:
          return this.openBus;
      }
    }

    write(addr, val) {
      switch (addr) {
        case 0x2000:
          this.ctrl = val;
          this.t = (this.t & 0xf3ff) | ((val & 0x03) << 10);
          break;
        case 0x2001:
          this.mask = val;
          break;
        case 0x2003:
          this.oamaddr = val;
          break;
        case 0x2004:
          this.oam[this.oamaddr++] = val;
          break;
        case 0x2005:
          if (this.w === 0) {
            this.x = val & 0x07;
            this.t = (this.t & 0x7fe0) | ((val & 0xf8) >> 3);
            this.w = 1;
          } else {
            this.t = (this.t & 0x0c1f) | ((val & 0x07) << 12) | ((val & 0xf8) << 2);
            this.w = 0;
          }
          break;
        case 0x2006:
          if (this.w === 0) {
            this.t = (this.t & 0x00ff) | ((val & 0x3f) << 8);
            this.w = 1;
          } else {
            this.t = (this.t & 0x7f00) | val;
            this.v = this.t;
            this.w = 0;
          }
          break;
        case 0x2007:
          this.ppuWrite(this.v, val);
          this.v += (this.ctrl & 0x04) ? 32 : 1;
          this.v &= 0x7fff;
          break;
      }
      this.openBus = val;
    }

    doDMA(buf) {
      for (let i = 0; i < 256; i++) this.oam[(this.oamaddr + i) & 0xff] = buf[i];
    }

    ntIndex(addr) {
      const a = (addr - 0x2000) & 0x0fff;
      const nt = (a >> 10) & 3;
      const off = a & 0x03ff;
      const mirror = this.mapper.mirroring || this.mirror; 
      
      if (mirror === "vertical") return ((nt & 1) * 0x400) + off;
      if (mirror === "horizontal") return (((nt >> 1) & 1) * 0x400) + off;
      if (mirror === "four") return a;
      return off; 
    }

    ppuRead(addr) {
      addr &= 0x3fff;
      if (addr < 0x2000) return this.mapper.chrRead(addr);
      if (addr < 0x3f00) return this.vram[this.ntIndex(addr)];
      let palAddr = addr & 0x1f;
      if ((palAddr & 3) === 0) palAddr &= 0x0F;
      return this.palette[palAddr];
    }

    ppuWrite(addr, val) {
      addr &= 0x3fff;
      val &= 0xff;
      if (addr < 0x2000) {
        this.mapper.chrWrite(addr, val);
        return;
      }
      if (addr < 0x3f00) {
        this.vram[this.ntIndex(addr)] = val;
        return;
      }
      let palAddr = addr & 0x1f;
      if ((palAddr & 3) === 0) palAddr &= 0x0F;
      this.palette[palAddr] = val;
    }

    incCoarseX() {
      if ((this.v & 0x001f) === 31) {
        this.v &= ~0x001f;
        this.v ^= 0x0400;
      } else {
        this.v++;
      }
    }

    incY() {
      if ((this.v & 0x7000) !== 0x7000) {
        this.v += 0x1000;
      } else {
        this.v &= ~0x7000;
        let y = (this.v & 0x03e0) >> 5;
        if (y === 29) {
          y = 0;
          this.v ^= 0x0800;
        } else if (y === 31) {
          y = 0;
        } else {
          y++;
        }
        this.v = (this.v & ~0x03e0) | (y << 5);
      }
    }

    copyX() {
      this.v = (this.v & ~0x041f) | (this.t & 0x041f);
    }

    copyY() {
      this.v = (this.v & ~0x7be0) | (this.t & 0x7be0);
    }

    bgFetch() {
      const nt = 0x2000 | (this.v & 0x0fff);
      const at =
        0x23c0 |
        (this.v & 0x0c00) |
        ((this.v >> 4) & 0x38) |
        ((this.v >> 2) & 0x07);
      const fineY = (this.v >> 12) & 7;
      
      const tile = this.ppuRead(nt);
      const attr = this.ppuRead(at);
      
      const coarseX = this.v & 0x1F;
      const coarseY = (this.v >> 5) & 0x1F;
      const shift = ((coarseY & 2) << 1) | (coarseX & 2);
      
      // [FIX] Removed the extra << 2 shift. 
      // reloadShifters expects bits 0-1 to contain the palette index (0-3).
      const pal = (attr >> shift) & 3; 
      
      const base = (this.ctrl & 0x10) ? 0x1000 : 0x0000;
      const addr = base + tile * 16 + fineY;
      const lo = this.ppuRead(addr);
      const hi = this.ppuRead(addr + 8);
      
      return { lo, hi, pal };
    }

    reloadShifters() {
      this.bgShiftLo = (this.bgShiftLo & 0xFF00) | this.bgLatch.lo;
      this.bgShiftHi = (this.bgShiftHi & 0xFF00) | this.bgLatch.hi;
      
      // Expand the 2-bit palette index into full bytes for the shift registers
      const attrLo = (this.bgLatch.pal & 1) ? 0xFF : 0x00;
      const attrHi = (this.bgLatch.pal & 2) ? 0xFF : 0x00;
      
      this.bgAttrShiftLo = (this.bgAttrShiftLo & 0xFF00) | attrLo;
      this.bgAttrShiftHi = (this.bgAttrShiftHi & 0xFF00) | attrHi;
    }

    evalSprites() {
      const y = this.scanline;
      this.spriteCount = 0;
      this.spriteZeroInLine = false;
      for (let i = 0; i < 64; i++) {
        const o = i * 4;
        const sy = this.oam[o];
        const tile = this.oam[o + 1];
        const attr = this.oam[o + 2];
        const sx = this.oam[o + 3];
        const h = (this.ctrl & 0x20) ? 16 : 8;
        const row = y - sy;
        if (row >= 0 && row < h && this.spriteCount < 8) {
          if (i === 0) this.spriteZeroInLine = true;
          this.secOAM[this.spriteCount * 4 + 0] = sy;
          this.secOAM[this.spriteCount * 4 + 1] = tile;
          this.secOAM[this.spriteCount * 4 + 2] = attr;
          this.secOAM[this.spriteCount * 4 + 3] = sx;
          this.spriteCount++;
          if (this.spriteCount === 8) {
            this.status |= 0x20; 
            break;
          }
        }
      }
    }
    
    renderPixel(x, y) {
      const idx = (y * 256 + x) * 4;
      const img = this.output.data;
      let bgPx = 0, bgPal = 0;
      let spriteOpaque = false, spritePriority = 0, spritePx = 0, spritePal = 0;
      let sprite0 = false;

      // 1. Background Pixel Fetch
      if (this.mask & 0x08) {
        const bitMux = 15 - this.x;
        const p0 = (this.bgShiftLo >> bitMux) & 1;
        const p1 = (this.bgShiftHi >> bitMux) & 1;
        bgPx = (p1 << 1) | p0;
        
        const a0 = (this.bgAttrShiftLo >> bitMux) & 1;
        const a1 = (this.bgAttrShiftHi >> bitMux) & 1;
        bgPal = (a1 << 1) | a0;
      }

      // 2. Sprite Pixel Fetch
      if (this.mask & 0x10) {
        for (let i = 0; i < this.spriteCount; i++) {
          const o = i * 4;
          const sy = this.secOAM[o];
          const tile = this.secOAM[o + 1];
          const attr = this.secOAM[o + 2];
          const sx = this.secOAM[o + 3];
          
          if (x < sx || x >= sx + 8) continue;
          
          const h = (this.ctrl & 0x20) ? 16 : 8;
          const row = y - sy;
          if (row < 0 || row >= h) continue;
          
          if (i === 0 && this.spriteZeroInLine) sprite0 = true;
          
          const flipV = (attr >> 7) & 1;
          const flipH = (attr >> 6) & 1;
          spritePriority = (attr >> 5) & 1;
          const paletteIdx = (attr & 3);
          
          let fineY = flipV ? (h - 1 - row) : row;
          let tileNum = tile;
          let base = 0;
          
          if (h === 16) {
            base = (tile & 1) ? 0x1000 : 0x0000;
            tileNum = tile & 0xFE;
            if (fineY >= 8) {
              tileNum++;
              fineY -= 8;
            }
          } else {
            base = (this.ctrl & 0x08) ? 0x1000 : 0x0000;
          }
          
          const addr = base + tileNum * 16 + fineY;
          const lo = this.ppuRead(addr);
          const hi = this.ppuRead(addr + 8);
          
          const bit = flipH ? (x - sx) : (7 - (x - sx));
          const p0 = (lo >> bit) & 1;
          const p1 = (hi >> bit) & 1;
          spritePx = (p1 << 1) | p0;
          
          if (spritePx !== 0) {
            spriteOpaque = true;
            spritePal = paletteIdx;
            break;
          }
        }
      }

      // 3. Sprite 0 Hit
      if (sprite0 && spriteOpaque && bgPx !== 0) {
        if (x < 255 && x >= 8) {
          const bgOn = (this.mask & 0x08) !== 0;
          const sprOn = (this.mask & 0x10) !== 0;
          if (bgOn && sprOn) this.status |= 0x40;
        } else if (x < 255) {
          const leftBgOn = (this.mask & 0x02) !== 0;
          const leftSprOn = (this.mask & 0x04) !== 0;
          if ((this.mask & 0x08) && (this.mask & 0x10) && leftBgOn && leftSprOn) {
            this.status |= 0x40;
          }
        }
      }
      
      // 4. Final Color Selection
      let paletteIndex = 0;
      const bgOpaque = bgPx !== 0;
      const sprOpaque = spriteOpaque && spritePx !== 0;
      
      if (!bgOpaque && !sprOpaque) {
        paletteIndex = 0;
      } else if (bgOpaque && !sprOpaque) {
        paletteIndex = (bgPal << 2) | bgPx;
      } else if (!bgOpaque && sprOpaque) {
        paletteIndex = 0x10 | (spritePal << 2) | spritePx;
      } else {
        if (spritePriority === 0) {
          paletteIndex = 0x10 | (spritePal << 2) | spritePx;
        } else {
          paletteIndex = (bgPal << 2) | bgPx;
        }
      }
      
      // Leftmost 8 pixels clipping
      if (x < 8) {
        if (!(this.mask & 0x02) && bgOpaque) {
          if (!sprOpaque) paletteIndex = 0;
          else if (spritePriority === 0) paletteIndex = 0x10 | (spritePal << 2) | spritePx;
          else paletteIndex = 0;
        }
        if (!(this.mask & 0x04) && sprOpaque) {
          if (!bgOpaque) paletteIndex = 0;
          else paletteIndex = (bgPal << 2) | bgPx;
        }
        if (!(this.mask & 0x02) && !(this.mask & 0x04)) paletteIndex = 0;
      }
      
      const color = this.ppuRead(0x3F00 + (paletteIndex & 0x1F));
      const rgb = NTSC_PALETTE[color & 0x3F];
      
      img[idx] = rgb[0];
      img[idx + 1] = rgb[1];
      img[idx + 2] = rgb[2];
      img[idx + 3] = 255;
    }
    
    step() {
      if(this.mapper && this.mapper.ppuCycle) this.mapper.ppuCycle();
      
      const renderingEnabled = (this.mask & 0x18) !== 0;
      
      if (this.scanline === 261 && this.cycle === 339 && renderingEnabled && this.oddFrame) {
        this.cycle = 0;
        this.scanline = 0;
        this.frame++;
        this.oddFrame = false;
        return;
      }
      
      // Pre-render
      if (this.scanline === 261) {
        if (this.cycle === 1) this.status &= ~(0x80 | 0x40 | 0x20);
        if (this.cycle >= 280 && this.cycle <= 304 && renderingEnabled) this.copyY();
        
        if (this.cycle >= 321 && this.cycle <= 336 && renderingEnabled) {
          this.bgShiftLo <<= 1;
          this.bgShiftHi <<= 1;
          this.bgAttrShiftLo <<= 1;
          this.bgAttrShiftHi <<= 1;
          
          const cycleInTile = (this.cycle - 1) % 8;
          if (cycleInTile === 1) this.bgLatch = this.bgFetch();
          if (cycleInTile === 0 && this.cycle > 321) this.reloadShifters();
          if (cycleInTile === 7) this.incCoarseX();
        }
      }
      
      // Visible
      if (this.scanline >= 0 && this.scanline < 240) {
        if (this.cycle === 1 && renderingEnabled) this.evalSprites();
        
        if (this.cycle >= 1 && this.cycle <= 256) {
          if (renderingEnabled) {
            this.bgShiftLo <<= 1;
            this.bgShiftHi <<= 1;
            this.bgAttrShiftLo <<= 1;
            this.bgAttrShiftHi <<= 1;
          }
          
          const cycleInTile = (this.cycle - 1) % 8;
          if (cycleInTile === 0 && renderingEnabled) this.reloadShifters();
          if (cycleInTile === 1 && renderingEnabled) this.bgLatch = this.bgFetch();
          
          this.renderPixel(this.cycle - 1, this.scanline);
          
          if (cycleInTile === 7 && renderingEnabled) this.incCoarseX();
        }
        
        if (this.cycle === 256 && renderingEnabled) this.incY();
        if (this.cycle === 257 && renderingEnabled) this.copyX();
        
        if (this.cycle >= 321 && this.cycle <= 336 && renderingEnabled) {
          this.bgShiftLo <<= 1;
          this.bgShiftHi <<= 1;
          this.bgAttrShiftLo <<= 1;
          this.bgAttrShiftHi <<= 1;
          
          const cycleInTile = (this.cycle - 1) % 8;
          if (cycleInTile === 0 && this.cycle > 321) this.reloadShifters();
          if (cycleInTile === 1) this.bgLatch = this.bgFetch();
          if (cycleInTile === 7) this.incCoarseX();
        }
      }
      
      if (this.scanline === 241 && this.cycle === 1) {
        this.status |= 0x80;
        if (this.ctrl & 0x80) this.nmiDelay = 2; 
        this.ctx.putImageData(this.output, 0, 0);
      }
      
      if (this.nmiDelay > 0) {
        this.nmiDelay--;
        if (this.nmiDelay === 0) this.nmi = true;
      }
      
      this.cycle++;
      if (this.cycle > 340) {
        this.cycle = 0;
        this.scanline++;
        if (this.scanline > 261) {
          this.scanline = 0;
          this.frame++;
          this.oddFrame = !this.oddFrame;
        }
      }
    }
  }
  // NES color palette
  const NTSC_PALETTE = [
    [124,124,124], [0,0,252], [0,0,188], [68,40,188], [148,0,132], [168,0,32], [168,16,0], [136,20,0],
    [80,48,0], [0,120,0], [0,104,0], [0,88,0], [0,64,88], [0,0,0], [0,0,0], [0,0,0],
    [188,188,188], [0,120,248], [0,88,248], [104,68,252], [216,0,204], [228,0,88], [248,56,0], [228,92,16],
    [172,124,0], [0,184,0], [0,168,0], [0,168,68], [0,136,136], [0,0,0], [0,0,0], [0,0,0],
    [248,248,248], [60,188,252], [104,136,252], [152,120,248], [248,120,248], [248,88,152], [248,120,88], [252,160,68],
    [248,184,0], [184,248,24], [88,216,84], [88,248,152], [0,232,216], [120,120,120], [0,0,0], [0,0,0],
    [252,252,252], [164,228,252], [184,184,248], [216,184,248], [248,184,248], [248,164,192], [240,208,176], [252,224,168],
    [248,216,120], [216,248,120], [184,248,184], [184,248,216], [0,252,252], [248,216,248], [0,0,0], [0,0,0]
  ];


  // ===== 6502 CPU (official opcodes only) =====
  class CPU6502{
    constructor(bus){ this.bus=bus; this.a=0; this.x=0; this.y=0; this.sp=0xFD; this.p=0x24; this.pc=0; this.cycles=0; this.stall=0; this.resetVector=0x8000; this.irqLine=false; }
    getC(){return this.p&1;} setC(v){this.p = (this.p & ~1) | (v&1);} getZ(){return (this.p>>1)&1;} setZ(v){this.p = (this.p & ~2) | ((v?1:0)<<1);} getI(){return (this.p>>2)&1;} setI(v){this.p = (this.p & ~4) | ((v?1:0)<<2);} getD(){return (this.p>>3)&1;} setD(v){this.p = (this.p & ~8) | ((v?1:0)<<3);} getB(){return (this.p>>4)&1;} setB(v){this.p = (this.p & ~16)|((v?1:0)<<4);} getU(){return (this.p>>5)&1;} setU(v){this.p = (this.p & ~32)|((v?1:0)<<5);} getV(){return (this.p>>6)&1;} setV(v){this.p = (this.p & ~64)|((v?1:0)<<6);} getN(){return (this.p>>7)&1;} setN(v){this.p = (this.p & ~128)|((v?1:0)<<7);} 
    read(a){return this.bus.cpuRead(a);} write(a,v){this.bus.cpuWrite(a,v);} 
    push(v){this.write(0x100+this.sp, v); this.sp=u8(this.sp-1);} pop(){this.sp=u8(this.sp+1); return this.read(0x100+this.sp);} 
    reset(){ this.a=0; this.x=0; this.y=0; this.sp=0xFD; this.p=0x24; const lo=this.read(0xFFFC), hi=this.read(0xFFFD); this.pc=lo | (hi<<8); this.cycles=7; this.stall=0; }
    nmi(){ this.push((this.pc>>8)&0xFF); this.push(this.pc&0xFF); this.setB(0); this.setU(1); this.setI(1); this.push(this.p); const lo=this.read(0xFFFA), hi=this.read(0xFFFB); this.pc=lo|(hi<<8); this.cycles+=7; }
    irq(){ if(this.getI()) return; this.push((this.pc>>8)&0xFF); this.push(this.pc&0xFF); this.setB(0); this.setU(1); this.setI(1); this.push(this.p); const lo=this.read(0xFFFE), hi=this.read(0xFFFF); this.pc=lo|(hi<<8); this.cycles+=7; }

    step(){ 
      if(this.stall>0){ this.stall--; this.cycles++; return 1; }
      // [FIX] Check for IRQ line before executing instruction
      if(this.irqLine){ this.irq(); this.irqLine=false; }
      const op=this.read(this.pc++); const e = OPCODES[op]; if(!e){ return 2; }
      const {mode, ins, cyc} = e; this.addrMode=mode; this.pageCross=0; const addr = this.fetchAddr(mode);
      const cyclesBefore=this.cycles; this.execute(ins, addr); let c = cyc + this.pageCross; this.cycles += c; return this.cycles - cyclesBefore; }

    fetchAddr(mode){
      const zp=()=>this.read(this.pc++);
      const zpX=()=>u8(zp()+this.x);
      const zpY=()=>u8(zp()+this.y);
      const imm=()=>this.pc++;
      const abs=()=>{const lo=this.read(this.pc++), hi=this.read(this.pc++); return lo|(hi<<8)};
      const absX=()=>{const a=abs(); const res=u16(a+this.x); if((a^res)&0xFF00) this.pageCross=1; return res;}
      const absY=()=>{const a=abs(); const res=u16(a+this.y); if((a^res)&0xFF00) this.pageCross=1; return res;}
      const indX=()=>{const t = u8(this.read(this.pc++) + this.x); const lo=this.read(t), hi=this.read(u8(t+1)); return lo|(hi<<8)};
      const indY=()=>{const t = this.read(this.pc++); const lo=this.read(t), hi=this.read(u8(t+1)); const a=lo|(hi<<8); const res=u16(a+this.y); if((a^res)&0xFF00) this.pageCross=1; return res;}
      switch(mode){
        case 'IMP': return null; case 'IMM': return imm(); case 'ZP0': return zp(); case 'ZPX': return zpX(); case 'ZPY': return zpY();
        case 'ABS': return abs(); case 'ABX': return absX(); case 'ABY': return absY(); case 'IZX': return indX(); case 'IZY': return indY();
        case 'IND': {const ptr=abs(); const lo=this.read(ptr); const hi=this.read((ptr&0xFF00)|((ptr+1)&0xFF)); return lo|(hi<<8);} 
        case 'REL': {const off=u8(this.read(this.pc++)); return off<0x80? this.pc+off : this.pc+off-0x100;}
      }
    }
    setZN(v){ this.setZ((v&0xFF)===0); this.setN(v&0x80); }

    execute(ins, addr){
      const rd = a=>this.read(a); const wr=(a,v)=>this.write(a,u8(v));
      const ADC=v=>{const t=this.a+v+this.getC(); this.setC(t>0xFF); this.setV((~(this.a^v) & (this.a^t) & 0x80)); this.a=u8(t); this.setZN(this.a);}
      const SBC=v=>{ADC(v^0xFF)};
      const CMP=(r,v)=>{const t=r-v; this.setC(r>=v); this.setZN(u8(t));}
      const BIT=v=>{this.setZ((this.a & v)===0); this.setV(v&0x40); this.setN(v&0x80);}
      const branch=cond=>{ if(cond){ this.cycles++; if((this.pc&0xFF00)!=(addr&0xFF00)) this.cycles++; this.pc=addr; }}

      switch(ins){
        case 'BRK': this.pc++; this.push((this.pc>>8)&0xFF); this.push(this.pc&0xFF); this.setB(1); this.push(this.p); this.setI(1); this.pc = this.read(0xFFFE) | (this.read(0xFFFF)<<8); break;
        case 'NOP': break;
        case 'LDA': this.a=rd(addr); this.setZN(this.a); break;
        case 'LDX': this.x=rd(addr); this.setZN(this.x); break;
        case 'LDY': this.y=rd(addr); this.setZN(this.y); break;
        case 'STA': wr(addr,this.a); break;
        case 'STX': wr(addr,this.x); break;
        case 'STY': wr(addr,this.y); break;
        case 'TAX': this.x=this.a; this.setZN(this.x); break;
        case 'TAY': this.y=this.a; this.setZN(this.y); break;
        case 'TXA': this.a=this.x; this.setZN(this.a); break;
        case 'TYA': this.a=this.y; this.setZN(this.a); break;
        case 'TSX': this.x=this.sp; this.setZN(this.x); break;
        case 'TXS': this.sp=this.x; break;
        case 'PHA': this.push(this.a); break;
        case 'PHP': this.push(this.p|0x10); break;
        case 'PLA': this.a=this.pop(); this.setZN(this.a); break;
        case 'PLP': this.p=(this.pop()&0xEF)|0x20; break;
        case 'AND': this.a &= rd(addr); this.setZN(this.a); break;
        case 'ORA': this.a |= rd(addr); this.setZN(this.a); break;
        case 'EOR': this.a ^= rd(addr); this.setZN(this.a); break;
        case 'ADC': ADC(rd(addr)); break;
        case 'SBC': SBC(rd(addr)); break;
        case 'CMP': CMP(this.a, rd(addr)); break;
        case 'CPX': CMP(this.x, rd(addr)); break;
        case 'CPY': CMP(this.y, rd(addr)); break;
        case 'INC': {const v=u8(rd(addr)+1); wr(addr,v); this.setZN(v); } break;
        case 'INX': this.x=u8(this.x+1); this.setZN(this.x); break;
        case 'INY': this.y=u8(this.y+1); this.setZN(this.y); break;
        case 'DEC': {const v=u8(rd(addr)-1); wr(addr,v); this.setZN(v); } break;
        case 'DEX': this.x=u8(this.x-1); this.setZN(this.x); break;
        case 'DEY': this.y=u8(this.y-1); this.setZN(this.y); break;
        case 'ASL': if(this.addrMode==='IMP'){ this.setC(this.a>>7); this.a=u8(this.a<<1); this.setZN(this.a);} else { const v=rd(addr); this.setC(v>>7); const r=u8(v<<1); wr(addr,r); this.setZN(r);} break;
        case 'LSR': if(this.addrMode==='IMP'){ this.setC(this.a&1); this.a=u8(this.a>>>1); this.setZN(this.a);} else { const v=rd(addr); this.setC(v&1); const r=u8(v>>>1); wr(addr,r); this.setZN(r);} break;
        case 'ROL': if(this.addrMode==='IMP'){ const c=this.getC(); this.setC(this.a>>7); this.a=u8((this.a<<1)|c); this.setZN(this.a);} else { const v=rd(addr); const c=this.getC(); this.setC(v>>7); const r=u8((v<<1)|c); wr(addr,r); this.setZN(r);} break;
        case 'ROR': if(this.addrMode==='IMP'){ const c=this.getC(); this.setC(this.a&1); this.a=u8((this.a>>>1)|(c<<7)); this.setZN(this.a);} else { const v=rd(addr); const c=this.getC(); this.setC(v&1); const r=u8((v>>>1)|(c<<7)); wr(addr,r); this.setZN(r);} break;
        case 'BIT': BIT(rd(addr)); break;
        case 'JMP': this.pc = addr; break;
        case 'JSR': {const t=u16(this.pc-1); this.push((t>>8)&0xFF); this.push(t&0xFF); this.pc=addr;} break;
        case 'RTS': {const lo=this.pop(), hi=this.pop(); this.pc = ((hi<<8)|lo) + 1;} break;
        case 'RTI': {this.p=(this.pop()&0xEF)|0x20; const lo=this.pop(), hi=this.pop(); this.pc=(hi<<8)|lo;} break;
        case 'BCC': {const cond=!this.getC(); if(cond){ this.cycles++; if((this.pc&0xFF00)!=(addr&0xFF00)) this.cycles++; this.pc=addr; }} break;
        case 'BCS': {const cond=this.getC(); if(cond){ this.cycles++; if((this.pc&0xFF00)!=(addr&0xFF00)) this.cycles++; this.pc=addr; }} break;
        case 'BEQ': {const cond=this.getZ(); if(cond){ this.cycles++; if((this.pc&0xFF00)!=(addr&0xFF00)) this.cycles++; this.pc=addr; }} break;
        case 'BMI': {const cond=this.getN(); if(cond){ this.cycles++; if((this.pc&0xFF00)!=(addr&0xFF00)) this.cycles++; this.pc=addr; }} break;
        case 'BNE': {const cond=!this.getZ(); if(cond){ this.cycles++; if((this.pc&0xFF00)!=(addr&0xFF00)) this.cycles++; this.pc=addr; }} break;
        case 'BPL': {const cond=!this.getN(); if(cond){ this.cycles++; if((this.pc&0xFF00)!=(addr&0xFF00)) this.cycles++; this.pc=addr; }} break;
        case 'BVC': {const cond=!this.getV(); if(cond){ this.cycles++; if((this.pc&0xFF00)!=(addr&0xFF00)) this.cycles++; this.pc=addr; }} break;
        case 'BVS': {const cond=this.getV(); if(cond){ this.cycles++; if((this.pc&0xFF00)!=(addr&0xFF00)) this.cycles++; this.pc=addr; }} break;
        case 'CLC': this.setC(0); break; case 'SEC': this.setC(1); break; case 'CLI': this.setI(0); break; case 'SEI': this.setI(1); break; case 'CLV': this.setV(0); break; case 'CLD': this.setD(0); break; case 'SED': this.setD(1); break;
      }
    }
  }

  // Opcode table (official opcodes only)
  const O = (mode, ins, cyc) => ({mode, ins, cyc});
  const OPCODES = new Array(256);
  const fill = (list)=>list.forEach(([op,mode,ins,cyc])=>OPCODES[op]=O(mode,ins,cyc));
  fill([
    [0x00,'IMP','BRK',7],[0xEA,'IMP','NOP',2],
    [0xA9,'IMM','LDA',2],[0xA5,'ZP0','LDA',3],[0xB5,'ZPX','LDA',4],[0xAD,'ABS','LDA',4],[0xBD,'ABX','LDA',4],[0xB9,'ABY','LDA',4],[0xA1,'IZX','LDA',6],[0xB1,'IZY','LDA',5],
    [0xA2,'IMM','LDX',2],[0xA6,'ZP0','LDX',3],[0xB6,'ZPY','LDX',4],[0xAE,'ABS','LDX',4],[0xBE,'ABY','LDX',4],
    [0xA0,'IMM','LDY',2],[0xA4,'ZP0','LDY',3],[0xB4,'ZPX','LDY',4],[0xAC,'ABS','LDY',4],[0xBC,'ABX','LDY',4],
    [0x85,'ZP0','STA',3],[0x95,'ZPX','STA',4],[0x8D,'ABS','STA',4],[0x9D,'ABX','STA',5],[0x99,'ABY','STA',5],[0x81,'IZX','STA',6],[0x91,'IZY','STA',6],
    [0x86,'ZP0','STX',3],[0x96,'ZPY','STX',4],[0x8E,'ABS','STX',4],
    [0x84,'ZP0','STY',3],[0x94,'ZPX','STY',4],[0x8C,'ABS','STY',4],
    [0xAA,'IMP','TAX',2],[0xA8,'IMP','TAY',2],[0x8A,'IMP','TXA',2],[0x98,'IMP','TYA',2],
    [0xBA,'IMP','TSX',2],[0x9A,'IMP','TXS',2],
    [0x48,'IMP','PHA',3],[0x08,'IMP','PHP',3],[0x68,'IMP','PLA',4],[0x28,'IMP','PLP',4],
    [0x29,'IMM','AND',2],[0x25,'ZP0','AND',3],[0x35,'ZPX','AND',4],[0x2D,'ABS','AND',4],[0x3D,'ABX','AND',4],[0x39,'ABY','AND',4],[0x21,'IZX','AND',6],[0x31,'IZY','AND',5],
    [0x09,'IMM','ORA',2],[0x05,'ZP0','ORA',3],[0x15,'ZPX','ORA',4],[0x0D,'ABS','ORA',4],[0x1D,'ABX','ORA',4],[0x19,'ABY','ORA',4],[0x01,'IZX','ORA',6],[0x11,'IZY','ORA',5],
    [0x49,'IMM','EOR',2],[0x45,'ZP0','EOR',3],[0x55,'ZPX','EOR',4],[0x4D,'ABS','EOR',4],[0x5D,'ABX','EOR',4],[0x59,'ABY','EOR',4],[0x41,'IZX','EOR',6],[0x51,'IZY','EOR',5],
    [0x69,'IMM','ADC',2],[0x65,'ZP0','ADC',3],[0x75,'ZPX','ADC',4],[0x6D,'ABS','ADC',4],[0x7D,'ABX','ADC',4],[0x79,'ABY','ADC',4],[0x61,'IZX','ADC',6],[0x71,'IZY','ADC',5],
    [0xE9,'IMM','SBC',2],[0xE5,'ZP0','SBC',3],[0xF5,'ZPX','SBC',4],[0xED,'ABS','SBC',4],[0xFD,'ABX','SBC',4],[0xF9,'ABY','SBC',4],[0xE1,'IZX','SBC',6],[0xF1,'IZY','SBC',5],
    [0xC9,'IMM','CMP',2],[0xC5,'ZP0','CMP',3],[0xD5,'ZPX','CMP',4],[0xCD,'ABS','CMP',4],[0xDD,'ABX','CMP',4],[0xD9,'ABY','CMP',4],[0xC1,'IZX','CMP',6],[0xD1,'IZY','CMP',5],
    [0xE0,'IMM','CPX',2],[0xE4,'ZP0','CPX',3],[0xEC,'ABS','CPX',4],
    [0xC0,'IMM','CPY',2],[0xC4,'ZP0','CPY',3],[0xCC,'ABS','CPY',4],
    [0xE6,'ZP0','INC',5],[0xF6,'ZPX','INC',6],[0xEE,'ABS','INC',6],[0xFE,'ABX','INC',7],
    [0xC6,'ZP0','DEC',5],[0xD6,'ZPX','DEC',6],[0xCE,'ABS','DEC',6],[0xDE,'ABX','DEC',7],
    [0xE8,'IMP','INX',2],[0xC8,'IMP','INY',2],[0xCA,'IMP','DEX',2],[0x88,'IMP','DEY',2],
    [0x0A,'IMP','ASL',2],[0x06,'ZP0','ASL',5],[0x16,'ZPX','ASL',6],[0x0E,'ABS','ASL',6],[0x1E,'ABX','ASL',7],
    [0x4A,'IMP','LSR',2],[0x46,'ZP0','LSR',5],[0x56,'ZPX','LSR',6],[0x4E,'ABS','LSR',6],[0x5E,'ABX','LSR',7],
    [0x2A,'IMP','ROL',2],[0x26,'ZP0','ROL',5],[0x36,'ZPX','ROL',6],[0x2E,'ABS','ROL',6],[0x3E,'ABX','ROL',7],
    [0x6A,'IMP','ROR',2],[0x66,'ZP0','ROR',5],[0x76,'ZPX','ROR',6],[0x6E,'ABS','ROR',6],[0x7E,'ABX','ROR',7],
    [0x24,'ZP0','BIT',3],[0x2C,'ABS','BIT',4],
    [0x4C,'ABS','JMP',3],[0x6C,'IND','JMP',5],
    [0x20,'ABS','JSR',6],[0x60,'IMP','RTS',6],[0x40,'IMP','RTI',6],
    [0x90,'REL','BCC',2],[0xB0,'REL','BCS',2],[0xF0,'REL','BEQ',2],[0x30,'REL','BMI',2],[0xD0,'REL','BNE',2],[0x10,'REL','BPL',2],[0x50,'REL','BVC',2],[0x70,'REL','BVS',2],
    [0x18,'IMP','CLC',2],[0x38,'IMP','SEC',2],[0x58,'IMP','CLI',2],[0x78,'IMP','SEI',2],[0xB8,'IMP','CLV',2],[0xD8,'IMP','CLD',2],[0xF8,'IMP','SED',2],
  ]);
  


 // ===== NES Machine =====
  class NES {
    constructor(canvas) {
      this.ppu = new PPU();
      this.ppu.attachCanvas(canvas);
      this.input = new Controllers();
      this.cart = null;
      this.bus = null;
      this.cpu = null;
      this.apu = new APU();
      this.running = false;
      this.makeResponsiveCanvas();
      
      // Timing
      this._lastFrameTime = 0;
      this._frameInterval = 1000/60;
      this._pendingFrames = 0;
      this._lastFpsUpdate = performance.now();
      this._frameCount = 0;
    }

    makeResponsiveCanvas() {
      const c = this.ppu.canvas;
      const resize = () => {
        if(window.innerWidth < 900) {
          c.style.width = "98vw";
          c.style.height = Math.round(240*98/256) + "vw";
        } else {
          c.style.width = "768px";
          c.style.height = "720px";
        }
      };
      window.addEventListener('resize', resize);
      resize();
    }

    loadROM(bytes) {
      this.cart = new Cartridge(bytes);
      this.ppu.connectCart(this.cart);
      
      this.bus = new Bus(null, this.ppu, this.cart, this.input, this.apu);
      this.cpu = new CPU6502(this.bus);
      this.bus.cpu = this.cpu;
      
      // [CRITICAL] Dependency Injection for Mapper 4
      if (this.ppu.mapper instanceof Mapper4) {
          this.ppu.mapper.cpu = this.cpu;
          this.ppu.mapper.ppu = this.ppu;
      }
      
      this.cpu.reset();
      
      // UI Updates
      const elMap = document.getElementById('mapper');
      const elMir = document.getElementById('mirror');
      if(elMap) elMap.textContent = this.cart.mapper;
      if(elMir) elMir.textContent = this.cart.mirror;
    }

    reset() {
      if (!this.cpu) return;
      this.cpu.reset();
      this.ppu.reset();
    }

    step() {
      const cyc = this.cpu.step();
      // PPU runs 3x faster than CPU
      for (let i = 0; i < cyc * 3; i++) {
        this.ppu.step();
        if (this.ppu.nmi) {
          this.cpu.nmi();
          this.ppu.nmi = false;
        }
      }
      this.apu.step(cyc);
    }

        run() {
      if (this.running) return;
      this.running = true;
      this._lastFrameTime = performance.now();
      this._pendingFrames = 0;

      const animate = (now) => {
        if (!this.running) return;
        let dt = now - this._lastFrameTime;
        if (dt > 1000) dt = 0;
        // Cap large lags
        this._lastFrameTime = now;
        
        this._pendingFrames += dt / this._frameInterval;
        let framesToRun = Math.floor(this._pendingFrames);
        this._pendingFrames -= framesToRun;
        
        if (framesToRun > 5) framesToRun = 5;
        // Prevent spiral of death

        for (let f = 0; f < framesToRun; ++f) {
          // Run 1 Frame (~29780 CPU cycles)
          let cpuCycles = 0;
          while (cpuCycles < 29780) {
            // [FIX] Capture actual cycles used by the instruction
            const cyc = this.cpu.step();
            cpuCycles += cyc;
            
            // [FIX] Run PPU 3x for EVERY CPU cycle consumed
            for (let i = 0; i < cyc * 3; i++) {
              this.ppu.step();
              if (this.ppu.nmi) {
                this.cpu.nmi();
                this.ppu.nmi = false;
              }
            }
            // [FIX] Step APU by the correct number of CPU cycles
            this.apu.step(cyc);
          }
          this._frameCount++;
        }
        
        // FPS Counter
        if (performance.now() - this._lastFpsUpdate >= 1000) {
          const elFps = document.getElementById('fps');
          const elMhz = document.getElementById('mhz');
          const elIrqs = document.getElementById('irqs');
          if(elFps) elFps.textContent = this._frameCount;
          if(elMhz) elMhz.textContent = "~1.79";
          // [FIX] Display IRQ counter for MMC3 debugging
          if(elIrqs && this.ppu.mapper instanceof Mapper4) {
            elIrqs.textContent = `Cnt:${this.ppu.mapper.irqCounter} En:${this.ppu.mapper.irqEnable?'Y':'N'}`;
          } else if(elIrqs) {
            elIrqs.textContent = '—';
          }
          this._frameCount = 0;
          this._lastFpsUpdate = performance.now();
        }
        requestAnimationFrame(animate);
      };
      requestAnimationFrame(animate);
    }
    pause() { this.running = false; }
  }
  // ===== UI glue =====
  const canvas = document.getElementById('screen');
  const nes = new NES(canvas);
  const romInput = document.getElementById('rom');
  const btnRun = document.getElementById('btnRun');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');
  const romName = document.getElementById('romName');

  romInput.addEventListener('change', async (e)=>{
    const f=e.target.files[0]; if(!f) return; romName.textContent=f.name;
    const buf = new Uint8Array(await f.arrayBuffer());
    try {
      nes.loadROM(buf); btnRun.disabled=false; btnPause.disabled=false; btnReset.disabled=false;
    } catch(err){ alert('ROM load failed: '+err.message); btnRun.disabled=true; btnPause.disabled=true; btnReset.disabled=true; }
  });

  btnRun.addEventListener('click',()=>nes.run());
  btnPause.addEventListener('click',()=>nes.pause());
  btnReset.addEventListener('click',()=>nes.reset());

  // Prevent scrolling/touchmove on body and document
  window.addEventListener('touchmove', function(e){ e.preventDefault(); }, {passive:false});
  window.addEventListener('scroll', function(){ window.scrollTo(0,0); }, {passive:false});
  document.body.addEventListener('wheel', function(e){ e.preventDefault(); }, {passive:false});
})();
</script>
</body>
</html>
